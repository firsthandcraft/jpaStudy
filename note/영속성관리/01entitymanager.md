
[p 90~ 94]
### 영속성 컨텍스트
> "엔티티를 영구 저장하는 환경"

#### 웹어플리케이션은
엔티티팩토리에서 >>(엔티티 생성 메니저에게줌)>> 엔티티메니저할당

01. 엔티티 매네저 팩토리: 엔티티를 만드는 공장.

02. 엔티티메니저: 영속성 컨텍스트에 엔티티를 보관,관리/ 하나의 엔티티만 관리
> 여기서 엔티티 메니저를 사용해서 엔티티를 저장하고 조회 하려면 엔티티를 영구적으로 저장하는 환경이 필요한데 그것이 
 "/영속성 컨텍스트/" 이다.

엔티티가 영구저장이 왜되는지?
> 엔티티는 생명주기가 있다. 영속, 비영속, 준영속, 삭제가 있는데 이후 자세히 알아볼 예정 (코드로)

01. 비영속: 
    ```
    Member member = new Memeber();
    member.setId("Memeber");
    memeber.userId("회원1);
    ```

02. 영속 
    ```
        em.persist(memeber);
        //를 이후코드에 치는 순간 영속이 된다.
        //1차 캐시에 저장 
        //persist는 영속이 되는 순간으로 


        transaction.commit(); // flush가 되면서 저장됨 
        // commit 해야 트렌젝션으로 insert가되어 DB에 저장이 된다.
    ```
    | flush :: 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
    
    | `commit`은 `반영된 데이터베이스의 데이터를 영구적으로 저장하겠다`라고 선언하는 것과 같다.      
여기서 `반영된 데이터베이스의 데이터`이기 때문에 이전에 자동으로 `flush`를 수행한다.  

++ 영속성 컨텍스트를 플러시하는 방법

    • em.flush() - 직접 호출 

    • 트랜잭션 커밋 - 플러시 자동 호출 
    
    • JPQL 쿼리 실행 - 플러시 자동 호출 

03. 준영속(삭제)
    ```
        //영속성 컨텍스트에 분리
        em.detatch(member);
    ```
    ```
        //객체를 삭제한 상태
        em.remove(member);
    ```

#### 영속성 컨텍스트의 특징 
**영속성 컨텍스트와 식별자 값**    
* 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.   
* 따라서 **영속 상태는 식별자 값이 반드시 있어야 한다.**   
* 식별자가 없으면 예외가 발생한다.      
   
**영속성 컨텍스트와 데이터베이스 저장**   
* 영속성 컨텍스트에 엔티티를 저장하면  **트랜잭션을 `commit`하는 순간 영속성 컨텍스트에 존재하는 엔티티를 반영** 
* 영속성 컨텍스트에 존재하는 엔티티를 반영하는 것을 **플러시(flush)** 라 한다.    


#### 변경감지(DirtyChecking)
